# 프로젝트: jsonweblog

## 개요

`jsonweblog`는 표준 입력(stdin)으로 JSONL(JSON Lines) 형식의 로그를 받아, 웹 UI를 통해 실시간으로 모니터링하고 필터링할 수 있는 고성능 로그 뷰어입니다. Rust로 작성되었으며, `axum` 웹 프레임워크와 `tokio` 비동기 런타임을 기반으로 합니다.

## 핵심 기능

- **고성능 웹 UI**: 대용량 로그(수만 건 이상)도 성능 저하 없이 부드럽게 탐색할 수 있도록 **가상 스크롤(Virtual Scrolling)** 기술을 적용했습니다.
- **동적 스키마 및 커스텀 컬럼**: 첫 번째 로그의 구조를 분석하여 동적으로 테이블 컬럼을 생성합니다. 사용자는 UI를 통해 각 컬럼의 너비, 순서, 가시성을 자유롭게 커스터마이징하고 설정을 저장할 수 있습니다.
- **유연한 로그 파싱**: 다양한 형식의 `timestamp`, `level`, `message` 필드를 자동으로 인식하여 파싱합니다.
- **강력한 필터링**: 특정 컬럼의 값을 기준으로 로그를 실시간으로 필터링할 수 있습니다.
- **포트 자동 할당**: 지정된 포트가 이미 사용 중일 경우, 자동으로 사용 가능한 다음 포트를 찾아 서버를 실행합니다.
- **단일 바이너리 실행**: 웹 UI(HTML, CSS, JS)를 실행 파일 내에 모두 포함시켜, 별도의 정적 파일 없이 단일 바이너리만으로 모든 기능을 제공합니다.

## 작동 방식

1. **서버 시작**: `main.rs`에서 `WebServer`를 초기화하고, 명령줄 인자로 받은 포트(기본 3000) 또는 사용 가능한 포트에서 웹 서버를 실행합니다.
2. **표준 입력 처리**: `server.rs`의 `stdin_parser_task`가 백그라운드에서 비동기적으로 표준 입력을 감시합니다.
3. **로그 파싱**: `parser.rs`의 `JsonLogParser`가 stdin으로 들어온 각 줄을 JSON으로 파싱하여 `LogEntry` 객체로 변환합니다.
4. **상태 관리 및 브로드캐스트**: 파싱된 로그는 `server.rs`의 `AppState`에 저장되며, 동시에 WebSocket 채널(`log_tx`)을 통해 연결된 모든 웹 클라이언트에 실시간으로 전송됩니다.
5. **웹 UI 렌더링**: 사용자가 브라우저로 접속하면 `ui/static_files.rs`에 내장된 HTML, CSS, JS 파일을 받아 웹 UI가 렌더링됩니다.
6. **실시간 업데이트**: 웹 UI의 JavaScript(`app.js`)는 WebSocket 연결을 통해 새로운 로그를 수신하고, 가상 스크롤 뷰에 동적으로 로그를 추가합니다.

## 소스 코드 구조

- `src/main.rs`: 애플리케이션 진입점. 서버를 설정하고 실행합니다.
- `src/server.rs`: `axum` 웹 서버의 핵심 로직. 라우팅, WebSocket 처리, 상태 관리를 담당합니다.
- `src/parser.rs`: 표준 입력으로부터 JSONL 로그를 파싱하는 로직을 구현합니다.
- `src/log_entry.rs`: `LogEntry`, `LogLevel` 등 로그 데이터의 핵심 자료 구조를 정의합니다.
- `src/filter.rs`: 로그 필터링 로직을 담당합니다.
- `src/schema.rs`: 로그 데이터의 동적 스키마와 사용자가 설정한 테이블 컬럼 구성을 관리합니다.
- `src/ui/static_files.rs`: 웹 UI를 구성하는 HTML, CSS, JavaScript 파일을 Rust 상수로 포함하고 서빙하는 역할을 합니다.
